## API Report File for "git-documentdb"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Logger } from 'tslog';
import nodegit from '@sosuisen/nodegit';

// @public
export type AcceptedConflict = {
    target: DocMetadata;
    strategy: 'ours' | 'theirs';
    operation: WriteOperation;
};

// @public
export type AllDocsOptions = {
    include_docs?: boolean;
    descending?: boolean;
    recursive?: boolean;
    prefix?: string;
};

// @public
export type AllDocsResult = {
    total_rows: number;
    commit_sha?: string;
    rows?: JsonDocWithMetadata[];
};

// Warning: (ae-forgotten-export) The symbol "BaseError" needs to be exported by the entry point main.d.ts
//
// @public (undocumented)
export class AuthNeededForPushOrSyncError extends BaseError {
    constructor(direction: SyncDirection);
}

// @public
export type BehaviorForNoMergeBase = 'nop' | 'ours' | 'theirs';

// @public (undocumented)
export class CannotConnectError extends BaseError {
    constructor(retry: number, url: string, mes: string);
    // (undocumented)
    retry: number;
}

// @public (undocumented)
export class CannotCreateDirectoryError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class CannotCreateRemoteRepository extends BaseError {
    constructor(reason: string);
}

// @public (undocumented)
export class CannotDeleteDataError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class CannotOpenRepositoryError extends BaseError {
    constructor(err: string);
}

// @public (undocumented)
export class CannotPushBecauseUnfetchedCommitExistsError extends BaseError {
    constructor();
}

// @public (undocumented)
export class CannotWriteDataError extends BaseError {
    constructor(e?: string);
}

// @public
export type ChangedFile = {
    operation: WriteOperation;
    data: JsonDocWithMetadata;
};

// Warning: (ae-forgotten-export) The symbol "CRUDInterface" needs to be exported by the entry point main.d.ts
//
// @public
export class Collection implements CRUDInterface {
    // Warning: (ae-forgotten-export) The symbol "AbstractDocumentDB" needs to be exported by the entry point main.d.ts
    constructor(_gitDDB: CRUDInterface & AbstractDocumentDB, _collectionPath: CollectionPath);
    allDocs(options?: AllDocsOptions): Promise<AllDocsResult>;
    // (undocumented)
    collectionPath(): string;
    delete(id: string, options?: RemoveOptions): Promise<RemoveResult>;
    delete(jsonDoc: JsonDoc, options?: RemoveOptions): Promise<RemoveResult>;
    get(docId: string): Promise<JsonDoc>;
    put(jsonDoc: JsonDoc, options?: PutOptions): Promise<PutResult>;
    put(_id: string, document: {
        [key: string]: any;
    }, options?: PutOptions): Promise<PutResult>;
    remove(id: string, options?: RemoveOptions): Promise<RemoveResult>;
    remove(jsonDoc: JsonDoc, options?: RemoveOptions): Promise<RemoveResult>;
}

// @public
export type CollectionPath = string;

// @public
export type CommitInfo = {
    sha: string;
    date: Date;
    author: string;
    message: string;
};

// @public
export type ConflictResolveStrategies = 'ours' | 'theirs' | ((ours?: JsonDoc, theirs?: JsonDoc) => 'ours' | 'theirs');

// @public
export type DatabaseCloseOption = {
    force?: boolean;
    timeout?: number;
};

// @public (undocumented)
export class DatabaseCloseTimeoutError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class DatabaseClosingError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class DatabaseExistsError extends BaseError {
    constructor();
}

// @public
export type DatabaseInfo = DatabaseInfoSuccess | DatabaseInfoError;

// @public
export type DatabaseInfoError = {
    ok: false;
    error: Error;
};

// @public
export type DatabaseInfoSuccess = {
    ok: true;
    is_new: boolean;
    is_clone: boolean;
    is_created_by_gitddb: boolean;
    is_valid_version: boolean;
};

// @beta
export type DatabaseOption = {
    local_dir?: string;
    db_name: string;
};

// @public
export type DocMetadata = {
    id: string;
    file_sha: string;
    type?: 'json' | 'raw';
};

// @public (undocumented)
export class DocumentNotFoundError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class FileRemoveTimeoutError extends BaseError {
    constructor();
}

// @beta
export class GitDocumentDB extends AbstractDocumentDB implements CRUDInterface {
    constructor(options: DatabaseOption);
    allDocs(options?: AllDocsOptions): Promise<AllDocsResult>;
    close(options?: DatabaseCloseOption): Promise<void>;
    collection(collectionPath: CollectionPath): Collection;
    create(remoteOptions?: RemoteOptions): Promise<DatabaseInfo>;
    dbName(): string;
    // (undocumented)
    readonly defaultBranch = "main";
    delete(id: string, options?: RemoveOptions): Promise<RemoveResult>;
    delete(jsonDoc: JsonDoc, options?: RemoveOptions): Promise<RemoveResult>;
    destroy(options?: DatabaseCloseOption): Promise<{
        ok: true;
    }>;
    readonly fileExt = ".json";
    get(docId: string): Promise<JsonDoc>;
    getRemote(remoteURL: string): Sync;
    getRemoteURLs(): string[];
    readonly gitAuthor: {
        readonly name: "GitDocumentDB";
        readonly email: "gitddb@example.com";
    };
    isClosing: boolean;
    isOpened(): boolean;
    logger: Logger;
    open(): Promise<DatabaseInfo>;
    put(jsonDoc: JsonDoc, options?: PutOptions): Promise<PutResult>;
    put(_id: string, document: {
        [key: string]: any;
    }, options?: PutOptions): Promise<PutResult>;
    remove(id: string, options?: RemoveOptions): Promise<RemoveResult>;
    remove(jsonDoc: JsonDoc, options?: RemoveOptions): Promise<RemoveResult>;
    removeRemote(remoteURL: string): void;
    repository(): nodegit.Repository | undefined;
    sync(remoteURL: string, options?: RemoteOptions): Promise<Sync>;
    // (undocumented)
    sync(options?: RemoteOptions): Promise<Sync>;
    // Warning: (ae-forgotten-export) The symbol "TaskQueue" needs to be exported by the entry point main.d.ts
    taskQueue: TaskQueue;
    // Warning: (ae-incompatible-release-tags) The symbol "validator" is marked as @beta, but its signature references "Validator" which is marked as @internal
    validator: Validator;
    workingDir(): string;
    }

// @public (undocumented)
export class HTTPNetworkError extends BaseError {
    constructor(mes: string);
}

// @public (undocumented)
export class HttpProtocolRequiredError extends BaseError {
    constructor(url: string);
}

// @public (undocumented)
export class IntervalTooSmallError extends BaseError {
    constructor(min: number, current: number);
}

// @public (undocumented)
export class InvalidAuthenticationTypeError extends BaseError {
    constructor(type: string);
}

// @public (undocumented)
export class InvalidCollectionPathCharacterError extends BaseError {
    constructor(name: string);
}

// @public (undocumented)
export class InvalidCollectionPathError extends BaseError {
    constructor(name: string);
}

// @public (undocumented)
export class InvalidCollectionPathLengthError extends BaseError {
    constructor(collectionPath: string, minLength: number, maxLength: number);
}

// @public (undocumented)
export class InvalidConflictStateError extends BaseError {
    constructor(mes: string);
}

// @public (undocumented)
export class InvalidDbNameCharacterError extends BaseError {
    constructor(name: string);
}

// @public (undocumented)
export class InvalidIdCharacterError extends BaseError {
    constructor(id: string);
}

// @public (undocumented)
export class InvalidIdLengthError extends BaseError {
    constructor(id: string, minLength: number, maxLength: number);
}

// @public (undocumented)
export class InvalidJsonObjectError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class InvalidLocalDirCharacterError extends BaseError {
    constructor(name: string);
}

// @public (undocumented)
export class InvalidPropertyNameInDocumentError extends BaseError {
    constructor(name: string);
}

// @public (undocumented)
export class InvalidRepositoryURLError extends BaseError {
    constructor(url: string);
}

// @public (undocumented)
export class InvalidSSHKeyFormatError extends BaseError {
    constructor();
}

// @public (undocumented)
export class InvalidSSHKeyPathError extends BaseError {
    constructor();
}

// @public (undocumented)
export class InvalidURLFormatError extends BaseError {
    constructor(url: string);
}

// @public (undocumented)
export class InvalidWorkingDirectoryPathLengthError extends BaseError {
    constructor(path: string, minLength: number, maxLength: number);
}

// @public
export interface ISync {
    // (undocumented)
    author: nodegit.Signature;
    // (undocumented)
    cancel(): void;
    // (undocumented)
    committer: nodegit.Signature;
    // (undocumented)
    credential_callbacks: {
        [key: string]: any;
    };
    // (undocumented)
    currentRetries: () => number;
    // (undocumented)
    eventHandlers: {
        change: ((syncResult: SyncResult) => void)[];
        localChange: ((changedFiles: ChangedFile[]) => void)[];
        remoteChange: ((changedFiles: ChangedFile[]) => void)[];
        paused: (() => void)[];
        active: (() => void)[];
        start: ((taskId: string, currentRetries: number) => void)[];
        complete: ((taskId: string) => void)[];
        error: ((error: Error) => void)[];
    };
    // (undocumented)
    off(event: SyncEvent, callback: (result?: any) => void): void;
    // (undocumented)
    on(event: SyncEvent, callback: (result?: any) => void): void;
    // (undocumented)
    options(): RemoteOptions;
    // (undocumented)
    pause(): void;
    // (undocumented)
    remoteURL(): string;
    // (undocumented)
    resume(options?: {
        interval?: number;
        retry?: number;
    }): void;
    // (undocumented)
    tryPush(): Promise<SyncResultPush>;
    // (undocumented)
    trySync(): Promise<SyncResult>;
    // (undocumented)
    upstream_branch: string;
}

// @public
export type JsonDoc = {
    [key: string]: any;
};

// @public
export type JsonDocWithMetadata = DocMetadata & {
    doc?: JsonDoc;
};

// @public (undocumented)
export class NoMergeBaseFoundError extends BaseError {
    constructor();
}

// @public (undocumented)
export class PushAuthenticationError extends BaseError {
    constructor();
}

// @public (undocumented)
export class PushPermissionDeniedError extends BaseError {
    constructor();
}

// @public
export type PutOptions = {
    commit_message?: string;
};

// @public
export type PutResult = {
    ok: true;
    id: string;
    file_sha: string;
    commit_sha: string;
};

// @public (undocumented)
export class RemoteAlreadyRegisteredError extends BaseError {
    constructor(url: string);
}

// @public (undocumented)
export type RemoteAuth = RemoteAuthNone | RemoteAuthGitHub | RemoteAuthSSH;

// @public (undocumented)
export type RemoteAuthGitHub = {
    type: 'github';
    personal_access_token?: string;
};

// @public (undocumented)
export type RemoteAuthNone = {
    type: 'none';
};

// @public (undocumented)
export type RemoteAuthSSH = {
    type: 'ssh';
    private_key_path: string;
    public_key_path: string;
    pass_phrase?: string;
};

// @public
export type RemoteOptions = {
    remote_url?: string;
    live?: boolean;
    sync_direction?: SyncDirection;
    interval?: number;
    retry?: number;
    retry_interval?: number;
    auth?: RemoteAuth;
    behavior_for_no_merge_base?: BehaviorForNoMergeBase;
    include_commits?: boolean;
    conflict_resolve_strategy?: ConflictResolveStrategies;
};

// @public (undocumented)
export class RemoteRepository {
    constructor(remoteURL: string, auth?: RemoteAuth);
    connect(repos: nodegit.Repository, credential_callbacks: {
        [key: string]: any;
    }, onlyFetch?: boolean): Promise<string[]>;
    create(): Promise<void>;
    destroy(): Promise<void>;
    }

// @public (undocumented)
export class RemoteRepositoryNotFoundError extends BaseError {
    constructor(url: string);
}

// @public
export type RemoveOptions = {
    commit_message?: string;
};

// @public
export type RemoveResult = {
    ok: true;
    id: string;
    file_sha: string;
    commit_sha: string;
};

// @public (undocumented)
export class RepositoryNotFoundError extends BaseError {
    constructor(path: string);
}

// @public (undocumented)
export class RepositoryNotOpenError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class RequestTimeoutError extends BaseError {
    constructor(url: string);
}

// @public (undocumented)
export class SocketTimeoutError extends BaseError {
    constructor(url: string);
}

// @public
export class Sync implements ISync {
    constructor(_gitDDB: AbstractDocumentDB, _options?: RemoteOptions);
    // (undocumented)
    author: nodegit.Signature;
    cancel(): boolean;
    // (undocumented)
    close(): void;
    // (undocumented)
    committer: nodegit.Signature;
    // (undocumented)
    credential_callbacks: {
        [key: string]: any;
    };
    // (undocumented)
    currentRetries(): number;
    // (undocumented)
    static defaultRetry: number;
    // (undocumented)
    static defaultRetryInterval: number;
    // (undocumented)
    static defaultSyncInterval: number;
    // (undocumented)
    eventHandlers: {
        change: ((syncResult: SyncResult) => void)[];
        localChange: ((changedFiles: ChangedFile[]) => void)[];
        remoteChange: ((changedFiles: ChangedFile[]) => void)[];
        paused: (() => void)[];
        active: (() => void)[];
        start: ((taskId: string, currentRetries: number) => void)[];
        complete: ((taskId: string) => void)[];
        error: ((error: Error) => void)[];
    };
    init(repos: nodegit.Repository): Promise<SyncResult>;
    // (undocumented)
    static minimumSyncInterval: number;
    // (undocumented)
    off(event: SyncEvent, callback: (result?: any) => void): this;
    // (undocumented)
    on(event: SyncEvent, callback: (result?: any) => void): this;
    options(): any;
    pause(): boolean;
    remoteURL(): string;
    resume(options?: {
        interval?: number;
        retry?: number;
    }): boolean;
    tryPush(): Promise<SyncResultPush>;
    trySync(): Promise<SyncBaseType | SyncResultNop| SyncResultPush | SyncResultFastForwardMerge| SyncResultMergeAndPush| SyncResultResolveConflictsAndPush| SyncResultCancel>;
    // (undocumented)
    upstream_branch: string;
}

// @public (undocumented)
export type SyncBaseType = {
    action: string;
    changes?: {
        local?: ChangedFile[];
        remote?: ChangedFile[];
    };
    conflicts: AcceptedConflict[];
    commits?: {
        local?: CommitInfo[];
        remote?: CommitInfo[];
    };
};

// @public (undocumented)
export type SyncDirection = 'pull' | 'push' | 'both';

// @public
export type SyncEvent = 'change' | 'localChange' | 'remoteChange' | 'paused' | 'active' | 'start' | 'complete' | 'error';

// @public (undocumented)
export function syncImpl(this: AbstractDocumentDB, options?: RemoteOptions): Promise<Sync>;

// @public
export type SyncResult = SyncBaseType | SyncResultNop | SyncResultPush | SyncResultFastForwardMerge | SyncResultMergeAndPush | SyncResultResolveConflictsAndPush | SyncResultCancel;

// @public (undocumented)
export type SyncResultCancel = {
    action: 'canceled';
};

// @public (undocumented)
export type SyncResultFastForwardMerge = {
    action: 'fast-forward merge';
    changes: {
        local: ChangedFile[];
    };
    commits?: {
        local: CommitInfo[];
    };
};

// @public (undocumented)
export type SyncResultMergeAndPush = {
    action: 'merge and push';
    changes: {
        local: ChangedFile[];
        remote: ChangedFile[];
    };
    commits?: {
        local: CommitInfo[];
        remote: CommitInfo[];
    };
};

// @public (undocumented)
export type SyncResultNop = {
    action: 'nop';
};

// @public (undocumented)
export type SyncResultPush = {
    action: 'push';
    changes: {
        remote: ChangedFile[];
    };
    commits?: {
        remote: CommitInfo[];
    };
};

// @public (undocumented)
export type SyncResultResolveConflictsAndPush = {
    action: 'resolve conflicts and push';
    changes: {
        local: ChangedFile[];
        remote: ChangedFile[];
    };
    conflicts: AcceptedConflict[];
    commits?: {
        local: CommitInfo[];
        remote: CommitInfo[];
    };
};

// @public (undocumented)
export class SyncWorkerFetchError extends BaseError {
    constructor(mes: string);
}

// @public
export type Task = {
    label: TaskLabel;
    taskId: string;
    targetId?: string;
    func: (beforeResolve: () => void, beforeReject: () => void) => Promise<void>;
};

// @public
export type TaskLabel = 'put' | 'remove' | 'sync' | 'push';

// @public
export type TaskStatistics = {
    put: number;
    remove: number;
    push: number;
    sync: number;
};

// @public (undocumented)
export class UndefinedDatabaseNameError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class UndefinedDBError extends BaseError {
    constructor();
}

// @public (undocumented)
export class UndefinedDocumentIdError extends BaseError {
    constructor(e?: string);
}

// @public (undocumented)
export class UndefinedGitHubAuthenticationError extends BaseError {
    constructor(mes: string);
}

// @public (undocumented)
export class UndefinedPersonalAccessTokenError extends BaseError {
    constructor();
}

// @public (undocumented)
export class UndefinedRemoteURLError extends BaseError {
    constructor();
}

// @public (undocumented)
export class UnresolvedHostError extends BaseError {
    constructor(url: string);
}

// Warning: (ae-internal-missing-underscore) The name "Validator" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Validator {
    constructor(_workingDir: string);
    // (undocumented)
    static byteLengthOf: (str: string) => number;
    maxCollectionPathLength(): number;
    maxIdLength(): number;
    static maxWorkingDirectoryLength(): number;
    static normalizeCollectionPath(collectionPath: CollectionPath | undefined): CollectionPath;
    testWindowsInvalidFileNameCharacter(name: string, options?: {
        allow_slash?: boolean;
        allow_drive_letter?: boolean;
        allow_directory_dot?: boolean;
    }): boolean;
    testWindowsReservedFileName(name: string, options?: {
        allow_directory_dot?: boolean;
    }): boolean;
    validateCollectionPath(collectionPath: string): void;
    validateDbName(dbName: string): void;
    validateDocument(doc: JsonDoc): void;
    validateId(_id: string): void;
    validateLocalDir(localDir: string): void;
    }

// @public (undocumented)
export class WorkingDirectoryExistsError extends BaseError {
    constructor();
}

// @public
export type WriteOperation = 'create' | 'update' | 'delete';


```
